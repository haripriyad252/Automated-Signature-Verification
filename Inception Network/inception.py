# -*- coding: utf-8 -*-
"""Git Inception.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qxlq_w7zpQGxKW7gl-9kO8_ALNrsaG_w

# INCEPTION MODEL
"""

from __future__ import print_function
import keras
import math
import cv2
import numpy as np
from keras.models import Sequential
from keras.models import Model
from keras import backend as K
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D, concatenate, AveragePooling2D, GlobalAveragePooling2D
from keras.callbacks import LearningRateScheduler
from keras.optimizers import SGD, Adagrad, Adam

trainsize = 36 #18 genuine and 18 forged
testsize = 12 #6 genuine and 6 forged
img_rows, img_cols = 224, 224
Xtrain = np.zeros(shape=(trainsize,img_rows*img_cols)) #equal to number of users*no of training images, in this case, users and 18 training images = 40*18 = 720
Ytrain = np.zeros(shape=trainsize) # One hot encoding 720 images
Xtest = np.zeros(shape=(testsize,img_rows*img_cols)) #40 users * 6 images
Ytest = np.zeros(shape=testsize)

u=2
ctrain=0
ctest=0
img=0
for p in range(1,10): #getting genuine train images
  img = cv2.imread("c-00"+str(u)+"-0"+str(p)+".jpg", cv2.IMREAD_GRAYSCALE)
  print("Scanning Image:",p,"of user ",u)
  img = cv2.resize(img, (img_rows,img_cols))
  img = np.array(img)
  img = np.reshape(img, (1, img_rows*img_cols))
  Xtrain[ctrain] = img
  Ytrain[ctrain] = 1
  ctrain+= 1
for p in range(10,18+1):
  img = cv2.imread("c-00"+str(u)+"-"+str(p)+".jpg", cv2.IMREAD_GRAYSCALE)
  print("Scanning Image:",p,"of user ",u)
  img = cv2.resize(img, (img_rows,img_cols))
  img = np.array(img)
  img = np.reshape(img, (1, img_rows*img_cols))
  Xtrain[ctrain] = img
  Ytrain[ctrain] = 1
  ctrain+= 1
for p in range(1,10): #getting forged train images
  img = cv2.imread("cf-00"+str(u)+"-0"+str(p)+".jpg", cv2.IMREAD_GRAYSCALE)
  print("Scanning Image:",p,"of user ",u)
  img = cv2.resize(img, (img_rows,img_cols))
  img = np.array(img)
  img = np.reshape(img, (1, img_rows*img_cols))
  Xtrain[ctrain] = img
  Ytrain[ctrain] = 0
  ctrain+= 1
for p in range(10,18+1): #getting forged train images
  img = cv2.imread("cf-00"+str(u)+"-"+str(p)+".jpg", cv2.IMREAD_GRAYSCALE)
  print("Scanning Image:",p,"of user ",u)
  img = cv2.resize(img, (img_rows,img_cols))
  img = np.array(img)
  img = np.reshape(img, (1, img_rows*img_cols))
  Xtrain[ctrain] = img
  Ytrain[ctrain] = 0
  ctrain+= 1
  
#GETTING TEST IMAGES
for p in range(1,6+1): #getting genuine train images
  img = cv2.imread("c-00"+str(u)+"-0"+str(p)+".jpg", cv2.IMREAD_GRAYSCALE)
  print("Scanning Image:",p,"of user ",u)
  img = cv2.resize(img, (img_rows,img_cols))
  img = np.array(img)
  img = np.reshape(img, (1, img_rows*img_cols))
  Xtest[ctest] = img
  Ytest[ctest] = 1
  ctest+= 1
for p in range(1,6+1): #getting forged train images
  img = cv2.imread("cf-00"+str(u)+"-0"+str(p)+".jpg", cv2.IMREAD_GRAYSCALE)
  print("Scanning Image:",p,"of user ",u)
  img = cv2.resize(img, (img_rows,img_cols))
  img = np.array(img)
  img = np.reshape(img, (1, img_rows*img_cols))
  Xtest[ctest] = img
  Ytest[ctest] = 0
  ctest+= 1

from keras.layers import Input
if K.image_data_format() == 'channels_first':
    Xtrain = Xtrain.reshape(Xtrain.shape[0], 1, img_rows, img_cols)
    Xtest = Xtest.reshape(Xtest.shape[0], 1, img_rows, img_cols)
    input_img = Input(shape = (1, img_rows, img_cols))
else:
    Xtrain = Xtrain.reshape(Xtrain.shape[0], img_rows, img_cols, 1)
    Xtest = Xtest.reshape(Xtest.shape[0], img_rows, img_cols, 1)
    input_img = Input(shape = (img_rows, img_cols, 1))

#preprocessing
Xtrain = Xtrain.astype('float32')
Xtest = Xtest.astype('float32')
Xtrain /= img_rows
Xtest /= img_rows
print('Xtrain shape: ', Xtrain.shape)
print('Xtest shape: ', Xtest.shape)
print(Xtrain.shape[0], 'train samples')
print(Xtest.shape[0], 'test samples')

#one hot encoding
ytrain = keras.utils.to_categorical(Ytrain)
ytest = keras.utils.to_categorical(Ytest)
print("Ytrain shape ",ytrain.shape)
print("Ytest shape ",ytest.shape)

x = Conv2D(64, (7, 7), padding='same', strides=(2, 2), activation='relu', name='conv_1_7x7/2')(input_img)
x = MaxPooling2D((3, 3), padding='same', strides=(2, 2), name='max_pool_1_3x3/2')(x)
x = Conv2D(64, (1, 1), padding='same', strides=(1, 1), activation='relu', name='conv_2a_3x3/1')(x)
x = Conv2D(192, (3, 3), padding='same', strides=(1, 1), activation='relu', name='conv_2b_3x3/1')(x)
x = MaxPooling2D((3, 3), padding='same', strides=(2, 2), name='max_pool_2_3x3/2')(x)

#inception module 1
tower_1 = Conv2D(64, (1,1), padding='same', activation='relu')(x)
tower_2 = Conv2D(96, (1,1), padding='same', activation='relu')(x)
tower_2 = Conv2D(128, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(16, (1,1), padding='same', activation='relu')(x)
tower_3 = Conv2D(32, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(x)
tower_4 = Conv2D(32, (1,1), padding='same', activation='relu')(tower_4)
vol1 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

#inception module 2
tower_1 = Conv2D(128, (1,1), padding='same', activation='relu')(vol1)
tower_2 = Conv2D(128, (1,1), padding='same', activation='relu')(vol1)
tower_2 = Conv2D(192, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(32, (1,1), padding='same', activation='relu')(vol1)
tower_3 = Conv2D(96, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol1)
tower_4 = Conv2D(64, (1,1), padding='same', activation='relu')(tower_4)
vol2 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

vol2 = MaxPooling2D((3,3), strides=(2,2), padding='same')(vol2) #else use x = ... like original

#inception module 3
tower_1 = Conv2D(192, (1,1), padding='same', activation='relu')(vol2)
tower_2 = Conv2D(96, (1,1), padding='same', activation='relu')(vol2)
tower_2 = Conv2D(208, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(16, (1,1), padding='same', activation='relu')(vol2)
tower_3 = Conv2D(48, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol2)
tower_4 = Conv2D(64, (1,1), padding='same', activation='relu')(tower_4)
vol3 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

"""EXTRA MODULES"""

x1 = AveragePooling2D((5, 5), strides=3)(vol3)
x1 = Conv2D(128, (1, 1), padding='same', activation='relu')(x1)
x1 = Flatten()(x1)
x1 = Dense(1024, activation='relu')(x1)
x1 = Dropout(0.7)(x1)
x1 = Dense(2, activation='softmax', name='auxilliary_output_1')(x1)

tower_1 = Conv2D(160, (1,1), padding='same', activation='relu')(vol3)
tower_2 = Conv2D(112, (1,1), padding='same', activation='relu')(vol3)
tower_2 = Conv2D(224, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(24, (1,1), padding='same', activation='relu')(vol3)
tower_3 = Conv2D(64, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol3)
tower_4 = Conv2D(64, (1,1), padding='same', activation='relu')(tower_4)
vol4 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

tower_1 = Conv2D(128, (1,1), padding='same', activation='relu')(vol4)
tower_2 = Conv2D(128, (1,1), padding='same', activation='relu')(vol4)
tower_2 = Conv2D(256, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(24, (1,1), padding='same', activation='relu')(vol4)
tower_3 = Conv2D(64, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol4)
tower_4 = Conv2D(64, (1,1), padding='same', activation='relu')(tower_4)
vol5 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

tower_1 = Conv2D(112, (1,1), padding='same', activation='relu')(vol5)
tower_2 = Conv2D(144, (1,1), padding='same', activation='relu')(vol5)
tower_2 = Conv2D(288, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(32, (1,1), padding='same', activation='relu')(vol5)
tower_3 = Conv2D(64, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol5)
tower_4 = Conv2D(64, (1,1), padding='same', activation='relu')(tower_4)
vol6 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

tower_1 = Conv2D(256, (1,1), padding='same', activation='relu')(vol6)
tower_2 = Conv2D(160, (1,1), padding='same', activation='relu')(vol6)
tower_2 = Conv2D(320, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(32, (1,1), padding='same', activation='relu')(vol6)
tower_3 = Conv2D(128, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol6)
tower_4 = Conv2D(128, (1,1), padding='same', activation='relu')(tower_4)
vol7 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

vol7 = MaxPooling2D((3,3), padding='same', strides=(2,2))(vol7)

#inception module 8
tower_1 = Conv2D(256, (1,1), padding='same', activation='relu')(vol7)
tower_2 = Conv2D(160, (1,1), padding='same', activation='relu')(vol7)
tower_2 = Conv2D(320, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(32, (1,1), padding='same', activation='relu')(vol7)
tower_3 = Conv2D(128, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol7)
tower_4 = Conv2D(128, (1,1), padding='same', activation='relu')(tower_4)
vol8 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

#inception module 9
tower_1 = Conv2D(384, (1,1), padding='same', activation='relu')(vol8)
tower_2 = Conv2D(192, (1,1), padding='same', activation='relu')(vol8)
tower_2 = Conv2D(384, (3,3), padding='same', activation='relu')(tower_2)
tower_3 = Conv2D(48, (1,1), padding='same', activation='relu')(vol8)
tower_3 = Conv2D(128, (5,5), padding='same', activation='relu')(tower_3)
tower_4 = MaxPooling2D((3,3), strides=(1,1), padding='same')(vol8)
tower_4 = Conv2D(128, (1,1), padding='same', activation='relu')(tower_4)
vol9 = keras.layers.concatenate([tower_1, tower_2, tower_3, tower_4], axis = 3)

x = GlobalAveragePooling2D(name='avg_pool_5_3x3/1')(vol9)
x = Dropout(0.4)(x)
x = Dense(2, activation='softmax', name='output')(x)

from keras.layers import Flatten, Dense
output1 = Flatten()(vol9)
out1    = Dense(2, activation='softmax')(output1)

model1 = Model(inputs = input_img, outputs = x)
epochs = 20
lrate = 0.01
decay = lrate/epochs
sgd = SGD(lr=lrate, momentum=0.9, decay=decay, nesterov=False)
model1.compile(loss='categorical_crossentropy', optimizer=sgd, metrics=['accuracy'])

model1.fit(Xtrain, ytrain, validation_data=None, epochs=epochs, batch_size=32) #default 32
score = model1.evaluate(Xtest, ytest, verbose=0)
print('Test loss:', score[0])
print('Test accuracy:', score[1])

predict_inception = model1.predict(Xtrain)
print(predict_inception)